{"ast":null,"code":"!function (e, r) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = r() : \"function\" == typeof define && define.amd ? define([], r) : \"object\" == typeof exports ? exports = r() : e.rpc = r();\n}(\"undefined\" != typeof self ? self : this, function () {\n  return function (e) {\n    var r = {};\n    function t(n) {\n      if (r[n]) return r[n].exports;\n      var c = r[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return e[n].call(c.exports, c, c.exports, t), c.l = !0, c.exports;\n    }\n    return t.m = e, t.c = r, t.d = function (e, r, n) {\n      t.o(e, r) || Object.defineProperty(e, r, {\n        enumerable: !0,\n        get: n\n      });\n    }, t.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, t.t = function (e, r) {\n      if (1 & r && (e = t(e)), 8 & r) return e;\n      if (4 & r && \"object\" == typeof e && e && e.__esModule) return e;\n      var n = Object.create(null);\n      if (t.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & r && \"string\" != typeof e) for (var c in e) t.d(n, c, function (r) {\n        return e[r];\n      }.bind(null, c));\n      return n;\n    }, t.n = function (e) {\n      var r = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return t.d(r, \"a\", r), r;\n    }, t.o = function (e, r) {\n      return Object.prototype.hasOwnProperty.call(e, r);\n    }, t.p = \"\", t(t.s = 1);\n  }([function (e, r, t) {\n    \"use strict\";\n\n    var n;\n    t.d(r, \"i\", function () {\n      return o;\n    }), t.d(r, \"b\", function () {\n      return s;\n    }), t.d(r, \"h\", function () {\n      return i;\n    }), t.d(r, \"d\", function () {\n      return a;\n    }), t.d(r, \"f\", function () {\n      return l;\n    }), t.d(r, \"e\", function () {\n      return p;\n    }), t.d(r, \"g\", function () {\n      return u;\n    }), t.d(r, \"c\", function () {\n      return f;\n    }), t.d(r, \"a\", function () {\n      return _;\n    }), function (e) {\n      e.Blip = \"b\", e.Checkpoint = \"cp\", e.Colshape = \"c\", e.Label = \"l\", e.Marker = \"m\", e.Object = \"o\", e.Pickup = \"p\", e.Player = \"pl\", e.Vehicle = \"v\";\n    }(n || (n = {}));\n    function c(e, r) {\n      try {\n        const t = \"client\" === s();\n        if (e && \"object\" == typeof e && void 0 !== e.id) {\n          const c = (r, n, c) => t ? e.type === r && n.at(e.id) === e : e instanceof c;\n          switch (r) {\n            case n.Blip:\n              return c(\"blip\", mp.blips, mp.Blip);\n            case n.Checkpoint:\n              return c(\"checkpoint\", mp.checkpoints, mp.Checkpoint);\n            case n.Colshape:\n              return c(\"colshape\", mp.colshapes, mp.Colshape);\n            case n.Label:\n              return c(\"textlabel\", mp.labels, mp.TextLabel);\n            case n.Marker:\n              return c(\"marker\", mp.markers, mp.Marker);\n            case n.Object:\n              return c(\"object\", mp.objects, mp.Object);\n            case n.Pickup:\n              return c(\"pickup\", mp.pickups, mp.Pickup);\n            case n.Player:\n              return c(\"player\", mp.players, mp.Player);\n            case n.Vehicle:\n              return c(\"vehicle\", mp.vehicles, mp.Vehicle);\n          }\n        }\n        return !1;\n      } catch (e) {\n        0;\n      }\n    }\n    function o() {\n      try {\n        const e = 46656 * Math.random() | 0,\n          r = 46656 * Math.random() | 0,\n          t = (\"000\" + e.toString(36)).slice(-3);\n        return t + (\"000\" + r.toString(36)).slice(-3);\n      } catch (e) {\n        0;\n      }\n    }\n    function s() {\n      try {\n        if (mp.joaat) return \"server\";\n        if (mp.game && mp.game.joaat) return \"client\";\n        if (mp.trigger) return \"cef\";\n      } catch (e) {\n        0;\n      }\n    }\n    function i(e) {\n      try {\n        const r = s();\n        return JSON.stringify(e, (e, t) => {\n          if (\"client\" === r || \"server\" === r && t && \"object\" == typeof t) {\n            let e;\n            if (c(t, n.Blip) ? e = n.Blip : c(t, n.Checkpoint) ? e = n.Checkpoint : c(t, n.Colshape) ? e = n.Colshape : c(t, n.Marker) ? e = n.Marker : c(t, n.Object) ? e = n.Object : c(t, n.Pickup) ? e = n.Pickup : c(t, n.Player) ? e = n.Player : c(t, n.Vehicle) && (e = n.Vehicle), e) return {\n              __t: e,\n              i: \"number\" == typeof t.remoteId ? t.remoteId : t.id\n            };\n          }\n          return t;\n        });\n      } catch (e) {\n        0;\n      }\n    }\n    function a(e) {\n      try {\n        const r = s();\n        return JSON.parse(e, (e, t) => {\n          if ((\"client\" === r || \"server\" === r) && t && \"object\" == typeof t && \"string\" == typeof t.__t && \"number\" == typeof t.i && 2 === Object.keys(t).length) {\n            const e = t.i;\n            let c;\n            switch (t.__t) {\n              case n.Blip:\n                c = mp.blips;\n                break;\n              case n.Checkpoint:\n                c = mp.checkpoints;\n                break;\n              case n.Colshape:\n                c = mp.colshapes;\n                break;\n              case n.Label:\n                c = mp.labels;\n                break;\n              case n.Marker:\n                c = mp.markers;\n                break;\n              case n.Object:\n                c = mp.objects;\n                break;\n              case n.Pickup:\n                c = mp.pickups;\n                break;\n              case n.Player:\n                c = mp.players;\n                break;\n              case n.Vehicle:\n                c = mp.vehicles;\n            }\n            if (c) return c[\"client\" === r ? \"atRemoteId\" : \"at\"](e);\n          }\n          return t;\n        });\n      } catch (e) {\n        0;\n      }\n    }\n    function l(e) {\n      try {\n        return new Promise(r => setTimeout(() => r(e), 0));\n      } catch (e) {\n        0;\n      }\n    }\n    function p(e) {\n      try {\n        return new Promise((r, t) => setTimeout(() => t(e), 0));\n      } catch (e) {\n        0;\n      }\n    }\n    function u(e, r) {\n      try {\n        return \"number\" == typeof r ? Promise.race([new Promise((e, t) => {\n          setTimeout(() => t(\"TIMEOUT\"), r);\n        }), e]) : e;\n      } catch (e) {\n        0;\n      }\n    }\n    function f(e) {\n      try {\n        e.url;\n      } catch (e) {\n        return !1;\n      }\n      return !0;\n    }\n    function _(e, r) {\n      try {\n        const t = Math.ceil(e.length / r),\n          n = new Array(t);\n        let c = 0;\n        for (let o = 0; o < t; o += 1) n[o] = e.substr(c, r), c += r;\n        return n;\n      } catch (e) {\n        0;\n      }\n    }\n  }, function (e, r, t) {\n    \"use strict\";\n\n    t.r(r), function (e) {\n      t.d(r, \"register\", function () {\n        return p;\n      }), t.d(r, \"unregister\", function () {\n        return u;\n      }), t.d(r, \"call\", function () {\n        return f;\n      }), t.d(r, \"callServer\", function () {\n        return g;\n      }), t.d(r, \"callClient\", function () {\n        return m;\n      }), t.d(r, \"callBrowsers\", function () {\n        return y;\n      }), t.d(r, \"callBrowser\", function () {\n        return v;\n      }), t.d(r, \"on\", function () {\n        return P;\n      }), t.d(r, \"off\", function () {\n        return k;\n      }), t.d(r, \"trigger\", function () {\n        return B;\n      }), t.d(r, \"triggerClient\", function () {\n        return R;\n      }), t.d(r, \"triggerServer\", function () {\n        return O;\n      }), t.d(r, \"triggerBrowsers\", function () {\n        return x;\n      }), t.d(r, \"triggerBrowser\", function () {\n        return j;\n      });\n      var n = t(0);\n      const c = n.b();\n      if (!c) throw \"Unknown RAGE environment\";\n      const o = \"__rpc:triggerEvent\",\n        s = \"cef\" === c ? window : e;\n      if (!s[\"__rpc:processPartial\"]) try {\n        s.__rpcPartialData = {}, s[\"__rpc:processPartial\"] = (e, r, t, n, o) => {\n          \"server\" !== c && (o = n, n = t, t = r, r = e), s.__rpcPartialData[r] || (s.__rpcPartialData[r] = new Array(n)), s.__rpcPartialData[r][t] = o, s.__rpcPartialData[r].includes(void 0) || (\"server\" !== c ? s[\"__rpc:process\"](s.__rpcPartialData[r].join(\"\")) : s[\"__rpc:process\"](e, s.__rpcPartialData[r].join(\"\")), delete s.__rpcPartialData[r]);\n        };\n      } catch (e) {\n        0;\n      }\n      if (!s[\"__rpc:process\"]) try {\n        if (s.__rpcListeners = {}, s.__rpcPending = {}, s.__rpcEvListeners = {}, s[\"__rpc:process\"] = (e, r) => {\n          \"server\" !== c && (r = e);\n          const t = n.d(r);\n          if (t.req) {\n            const r = {\n              id: t.id,\n              environment: t.fenv || t.env\n            };\n            \"server\" === c && (r.player = e);\n            const o = {\n              ret: 1,\n              id: t.id,\n              env: c\n            };\n            let l;\n            switch (c) {\n              case \"server\":\n                l = e => r.player.call(\"__rpc:process\", [n.h(e)]);\n                break;\n              case \"client\":\n                if (\"server\" === t.env) l = e => mp.events.callRemote(\"__rpc:process\", n.h(e));else if (\"cef\" === t.env) {\n                  const e = t.b && s.__rpcBrowsers[t.b];\n                  r.browser = e, l = r => e && n.c(e) && i(e, r, !0);\n                }\n                break;\n              case \"cef\":\n                l = e => mp.trigger(\"__rpc:process\", n.h(e));\n            }\n            if (l) {\n              const e = a(t.name, t.args, r);\n              t.noRet || e.then(e => l({\n                ...o,\n                res: e\n              })).catch(e => l({\n                ...o,\n                err: e || null\n              }));\n            }\n          } else if (t.ret) {\n            const r = s.__rpcPending[t.id];\n            if (\"server\" === c && r.player !== e) return;\n            r && (r.resolve(t.hasOwnProperty(\"err\") ? n.e(t.err) : n.f(t.res)), delete s.__rpcPending[t.id]);\n          }\n        }, \"cef\" !== c) {\n          if (mp.events.add(\"__rpc:process\", s[\"__rpc:process\"]), mp.events.add(\"__rpc:processPartial\", s[\"__rpc:processPartial\"]), \"client\" === c) {\n            p(\"__rpc:callServer\", (_ref, n) => {\n              let [e, r, t] = _ref;\n              return _(e, r, {\n                fenv: n.environment,\n                noRet: t\n              });\n            }), p(\"__rpc:callBrowsers\", (_ref2, n) => {\n              let [e, r, t] = _ref2;\n              return w(null, e, r, {\n                fenv: n.environment,\n                noRet: t\n              });\n            }), s.__rpcBrowsers = {};\n            const e = e => {\n              const r = n.i();\n              Object.keys(s.__rpcBrowsers).forEach(r => {\n                const t = s.__rpcBrowsers[r];\n                t && n.c(t) && t !== e || delete s.__rpcBrowsers[r];\n              }), s.__rpcBrowsers[r] = e, e.execute(\"\\n                    window.name = '\".concat(r, \"';\\n                    if(typeof window['__rpc:id'] === 'undefined'){\\n                        window['__rpc:id'] = Promise.resolve(window.name);\\n                    }else{\\n                        window['__rpc:id:resolve'](window.name);\\n                    }\\n                \"));\n            };\n            mp.browsers.forEach(e), mp.events.add(\"browserCreated\", e), s.__rpcBrowserProcedures = {}, mp.events.add(\"__rpc:browserRegister\", e => {\n              const [r, t] = JSON.parse(e);\n              s.__rpcBrowserProcedures[t] = r;\n            }), mp.events.add(\"__rpc:browserUnregister\", e => {\n              const [r, t] = JSON.parse(e);\n              s.__rpcBrowserProcedures[t] === r && delete s.__rpcBrowserProcedures[t];\n            }), p(\"__rpc:triggerEventBrowsers\", (_ref3, t) => {\n              let [e, r] = _ref3;\n              Object.keys(s.__rpcBrowsers).forEach(c => {\n                const i = s.__rpcBrowsers[c];\n                i && n.c(i) ? d(i, o, [e, r], {\n                  fenv: t.environment,\n                  noRet: 1\n                }) : delete s.__rpcBrowsers[c];\n              });\n            });\n          }\n        } else void 0 === s[\"__rpc:id\"] && (s[\"__rpc:id\"] = new Promise(e => {\n          window.name ? e(window.name) : s[\"__rpc:id:resolve\"] = e;\n        }));\n        p(o, (_ref4, t) => {\n          let [e, r] = _ref4;\n          return b(e, r, t);\n        });\n      } catch (e) {\n        0;\n      }\n      function i(e, r, t) {\n        try {\n          const c = n.h(r);\n          e.execute(\"var process = window[\\\"__rpc:process\\\"]; if(process){ process(\".concat(JSON.stringify(c), \"); }else{ \").concat(t ? \"\" : \"mp.trigger(\\\"__rpc:process\\\", '{\\\"ret\\\":1,\\\"id\\\":\\\"\".concat(r.id, \"\\\",\\\"err\\\":\\\"PROCEDURE_NOT_FOUND\\\",\\\"env\\\":\\\"cef\\\"}');\"), \" }\"));\n        } catch (e) {\n          0;\n        }\n      }\n      function a(e, r, t) {\n        try {\n          const c = s.__rpcListeners[e];\n          return c ? n.f(c(r, t)) : n.e(\"PROCEDURE_NOT_FOUND (\".concat(e, \")\"));\n        } catch (e) {\n          0;\n        }\n      }\n      function l(e, r) {\n        try {\n          const t = {\n              client: function (e) {\n                for (var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  r[_key - 1] = arguments[_key];\n                }\n                return mp.events.callRemote(e, ...r);\n              },\n              server: function (e) {\n                for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                  t[_key2 - 1] = arguments[_key2];\n                }\n                return r.call(e, [...t]);\n              }\n            },\n            c = e.env,\n            o = n.h(e);\n          if (o.length > 32e3) {\n            const r = n.a(o, 32e3);\n            r.forEach((n, o) => {\n              t[c](\"__rpc:processPartial\", e.id, o, r.length, n);\n            });\n          } else t[c](\"__rpc:process\", o);\n        } catch (e) {\n          0;\n        }\n      }\n      function p(e, r) {\n        try {\n          if (2 !== arguments.length) throw 'register expects 2 arguments: \"name\" and \"cb\"';\n          return \"cef\" === c && s[\"__rpc:id\"].then(r => mp.trigger(\"__rpc:browserRegister\", JSON.stringify([r, e]))), s.__rpcListeners[e] = r, () => u(e);\n        } catch (e) {\n          0;\n        }\n      }\n      function u(e) {\n        try {\n          if (1 !== arguments.length) throw 'unregister expects 1 argument: \"name\"';\n          \"cef\" === c && s[\"__rpc:id\"].then(r => mp.trigger(\"__rpc:browserUnregister\", JSON.stringify([r, e]))), s.__rpcListeners[e] = void 0;\n        } catch (e) {\n          0;\n        }\n      }\n      function f(e, r) {\n        let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        try {\n          return arguments.length < 1 || arguments.length > 3 ? n.e('call expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"') : n.g(a(e, r, {\n            environment: c\n          }), t.timeout);\n        } catch (e) {\n          0;\n        }\n      }\n      function _(e, r) {\n        let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        try {\n          switch (c) {\n            case \"server\":\n              return f(e, r);\n            case \"client\":\n              {\n                const o = n.i();\n                return new Promise(n => {\n                  t.noRet || (s.__rpcPending[o] = {\n                    resolve: n\n                  });\n                  l({\n                    req: 1,\n                    id: o,\n                    name: e,\n                    env: c,\n                    args: r,\n                    ...t\n                  });\n                });\n              }\n            case \"cef\":\n              return m(\"__rpc:callServer\", [e, r, +t.noRet]);\n          }\n        } catch (e) {\n          0;\n        }\n      }\n      function g(e, r) {\n        let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        try {\n          if (arguments.length < 1 || arguments.length > 3) return n.e('callServer expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n          let c = {};\n          return t.noRet && (c.noRet = 1), n.g(_(e, r, c), t.timeout);\n        } catch (e) {\n          0;\n        }\n      }\n      function h(e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        try {\n          switch (c) {\n            case \"client\":\n              return f(r, t);\n            case \"server\":\n              {\n                const i = n.i();\n                return new Promise(n => {\n                  o.noRet || (s.__rpcPending[i] = {\n                    resolve: n,\n                    player: e\n                  });\n                  l({\n                    req: 1,\n                    id: i,\n                    name: r,\n                    env: c,\n                    args: t,\n                    ...o\n                  }, e);\n                });\n              }\n            case \"cef\":\n              {\n                const e = n.i();\n                return s[\"__rpc:id\"].then(i => new Promise(a => {\n                  o.noRet || (s.__rpcPending[e] = {\n                    resolve: a\n                  });\n                  const l = {\n                    b: i,\n                    req: 1,\n                    id: e,\n                    name: r,\n                    env: c,\n                    args: t,\n                    ...o\n                  };\n                  mp.trigger(\"__rpc:process\", n.h(l));\n                }));\n              }\n          }\n        } catch (e) {\n          0;\n        }\n      }\n      function m(e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        try {\n          switch (c) {\n            case \"client\":\n              if (o = t || {}, t = r, r = e, e = null, arguments.length < 1 || arguments.length > 3 || \"string\" != typeof r) return n.e('callClient from the client expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n              break;\n            case \"server\":\n              if (arguments.length < 2 || arguments.length > 4 || \"object\" != typeof e) return n.e('callClient from the server expects 2 to 4 arguments: \"player\", \"name\", optional \"args\", and optional \"options\"');\n              break;\n            case \"cef\":\n              if (o = t || {}, t = r, r = e, e = null, arguments.length < 1 || arguments.length > 3 || \"string\" != typeof r) return n.e('callClient from the browser expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n          }\n          let s = {};\n          return o.noRet && (s.noRet = 1), n.g(h(e, r, t, s), o.timeout);\n        } catch (e) {\n          0;\n        }\n      }\n      function d(e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        try {\n          return new Promise(a => {\n            const l = n.i();\n            o.noRet || (s.__rpcPending[l] = {\n              resolve: a\n            }), i(e, {\n              req: 1,\n              id: l,\n              name: r,\n              env: c,\n              args: t,\n              ...o\n            }, !1);\n          });\n        } catch (e) {\n          0;\n        }\n      }\n      function w(e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        try {\n          switch (c) {\n            case \"client\":\n              const c = s.__rpcBrowserProcedures[r];\n              if (!c) return n.e(\"PROCEDURE_NOT_FOUND (\".concat(r, \")\"));\n              const i = s.__rpcBrowsers[c];\n              return i && n.c(i) ? d(i, r, t, o) : n.e(\"PROCEDURE_NOT_FOUND\");\n            case \"server\":\n              return h(e, \"__rpc:callBrowsers\", [r, t, +o.noRet], o);\n            case \"cef\":\n              return h(null, \"__rpc:callBrowsers\", [r, t, +o.noRet], o);\n          }\n        } catch (e) {\n          0;\n        }\n      }\n      function y(e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        try {\n          let s,\n            i = {};\n          switch (c) {\n            case \"client\":\n            case \"cef\":\n              if (o = t || {}, t = r, r = e, arguments.length < 1 || arguments.length > 3) return n.e('callBrowsers from the client or browser expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n              o.noRet && (i.noRet = 1), s = w(null, r, t, i);\n              break;\n            case \"server\":\n              if (arguments.length < 2 || arguments.length > 4) return n.e('callBrowsers from the server expects 2 to 4 arguments: \"player\", \"name\", optional \"args\", and optional \"options\"');\n              o.noRet && (i.noRet = 1), s = w(e, r, t, i);\n          }\n          if (s) return n.g(s, o.timeout);\n        } catch (e) {\n          0;\n        }\n      }\n      function v(e, r, t) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        try {\n          if (\"client\" !== c) return n.e(\"callBrowser can only be used in the client environment\");\n          if (arguments.length < 2 || arguments.length > 4) return n.e('callBrowser expects 2 to 4 arguments: \"browser\", \"name\", optional \"args\", and optional \"options\"');\n          let s = {};\n          return o.noRet && (s.noRet = 1), n.g(d(e, r, t, s), o.timeout);\n        } catch (e) {\n          0;\n        }\n      }\n      function b(e, r, t) {\n        try {\n          const n = s.__rpcEvListeners[e];\n          n && n.forEach(e => e(r, t));\n        } catch (e) {\n          0;\n        }\n      }\n      function P(e, r) {\n        try {\n          if (2 !== arguments.length) throw 'on expects 2 arguments: \"name\" and \"cb\"';\n          const t = s.__rpcEvListeners[e] || new Set();\n          return t.add(r), s.__rpcEvListeners[e] = t, () => k(e, r);\n        } catch (e) {\n          0;\n        }\n      }\n      function k(e, r) {\n        try {\n          if (2 !== arguments.length) throw 'off expects 2 arguments: \"name\" and \"cb\"';\n          const t = s.__rpcEvListeners[e];\n          t && t.delete(r);\n        } catch (e) {\n          0;\n        }\n      }\n      function B(e, r) {\n        try {\n          if (arguments.length < 1 || arguments.length > 2) throw 'trigger expects 1 or 2 arguments: \"name\", and optional \"args\"';\n          b(e, r, {\n            environment: c\n          });\n        } catch (e) {\n          0;\n        }\n      }\n      function R(e, r, t) {\n        try {\n          switch (c) {\n            case \"client\":\n              if (t = r, r = e, e = null, arguments.length < 1 || arguments.length > 2 || \"string\" != typeof r) throw 'triggerClient from the client expects 1 or 2 arguments: \"name\", and optional \"args\"';\n              break;\n            case \"server\":\n              if (arguments.length < 2 || arguments.length > 3 || \"object\" != typeof e) throw 'triggerClient from the server expects 2 or 3 arguments: \"player\", \"name\", and optional \"args\"';\n              break;\n            case \"cef\":\n              if (t = r, r = e, e = null, arguments.length < 1 || arguments.length > 2 || \"string\" != typeof r) throw 'triggerClient from the browser expects 1 or 2 arguments: \"name\", and optional \"args\"';\n          }\n          h(e, o, [r, t], {\n            noRet: 1\n          });\n        } catch (e) {\n          0;\n        }\n      }\n      function O(e, r) {\n        try {\n          if (arguments.length < 1 || arguments.length > 2) throw 'triggerServer expects 1 or 2 arguments: \"name\", and optional \"args\"';\n          _(o, [e, r], {\n            noRet: 1\n          });\n        } catch (e) {\n          0;\n        }\n      }\n      function x(e, r, t) {\n        try {\n          switch (c) {\n            case \"client\":\n            case \"cef\":\n              if (t = r, r = e, e = null, arguments.length < 1 || arguments.length > 2) throw 'triggerBrowsers from the client or browser expects 1 or 2 arguments: \"name\", and optional \"args\"';\n              break;\n            case \"server\":\n              if (arguments.length < 2 || arguments.length > 3) throw 'triggerBrowsers from the server expects 2 or 3 arguments: \"player\", \"name\", and optional \"args\"';\n          }\n          h(e, \"__rpc:triggerEventBrowsers\", [r, t], {\n            noRet: 1\n          });\n        } catch (e) {\n          0;\n        }\n      }\n      function j(e, r, t) {\n        try {\n          if (\"client\" !== c) throw \"callBrowser can only be used in the client environment\";\n          if (arguments.length < 2 || arguments.length > 4) throw 'callBrowser expects 2 or 3 arguments: \"browser\", \"name\", and optional \"args\"';\n          d(e, o, [r, t], {\n            noRet: 1\n          });\n        } catch (e) {\n          0;\n        }\n      }\n      r.default = {\n        register: p,\n        unregister: u,\n        call: f,\n        callServer: g,\n        callClient: m,\n        callBrowsers: y,\n        callBrowser: v,\n        on: P,\n        off: k,\n        trigger: B,\n        triggerServer: O,\n        triggerClient: R,\n        triggerBrowsers: x,\n        triggerBrowser: j\n      };\n    }.call(this, t(2));\n  }, function (e, r) {\n    var t;\n    t = function () {\n      return this;\n    }();\n    try {\n      t = t || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == typeof window && (t = window);\n    }\n    e.exports = t;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}